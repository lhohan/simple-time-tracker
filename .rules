# Development Guidelines

## 1. Evolution Strategy

- Begin with the smallest end-to-end solution that works
- Start with hardcoded values; generalize once validated
- Separate feature additions from refactoring

## 2. Testing Approach

- Verify observable behaviors over implementation mechanics
- Compose tests using reusable builders and utilities
- Assert outcomes through domain language

## 3. Error Handling

- Design error types to mirror domain failure modes
- Preserve error sources when propagating upward
- Validate early, handle centrally

## 4. Domain Modeling

- Create distinct types for domain concepts
- Express business rules through type relationships
- Derive aggregate properties at creation time

## 5. Code Structure

- Group code by user-facing capabilities
- Separate sequential processing stages
- Favor immutable data transformations

## 6. Rust Specifics

- Enforce valid states through type constraints
- Design expressive fluent interfaces
- Encode business logic in type definitions rather than runtime checks
  - Use types as guardrails rather than writing if checks scattered through business logic

## 7. Documentation

- Lead with concrete usage examples
- Anchor documentation near usage context
